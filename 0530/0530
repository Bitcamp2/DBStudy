--35.
--1) SCORE 테이블과 동일한 구조를 갖는 SCORE_CHK를 생성하고 RESULT 60이상 90이하만 입력 가능하도록 하세요.
CREATE TABLE SCORE_CHK(
	SNO VARCHAR2(8),
	CNO VARCHAR2(8),
	RESULT NUMBER(3,0) CHECK(RESULT BETWEEN 60 AND 90)
);

--2) STUDENT 테이블과 동일한 구조를 갖는 STUDENT_COPY 테이블을 생성하면서 SNO은 PK로 SNAME은 NOT NULL로 SYEAR의 DEFAULT는 1로 
--   설정하세요.
CREATE TABLE STUDENT_COPY(
	SNO VARCHAR2(8) PRIMARY KEY,
	SNAME VARCHAR2(20) NOT NULL,
	SEX VARCHAR2(3),
	SYEAR NUMBER(1,0) DEFAULT 1,
	MAJOR VARCHAR2(20),
	AVR NUMBER(4,2)
);

--3) COURSE 테이블과 동일한 구조를 갖는 COURSE_CONTSRAINT 테이블을 생성하면서 
--CNO, CNAME을 PK로 PNO은 PROFESSOR_PK의 PNO을 참조하여
--   FK로 설정하고 ST_NUM은 DEFAULT 2로 설정하세요.
CREATE TABLE PROFESSOR_PK
AS SELECT * FROM PROFESSOR;

ALTER TABLE PROFESSOR_PK
ADD CONSTRAINT PK_PROFESSOR_PK_PNO PRIMARY KEY(PNO);

CREATE TABLE COURSE_CONTSRAINT(
	CNO VARCHAR2(8),
	CNAME VARCHAR2(20),
	ST_NUM NUMBER(1,0) DEFAULT 2,
	PNO VARCHAR2(8),
	CONSTRAINT PK_C_CONTS_CO_CN PRIMARY KEY(CNO,CNAME),
	CONSTRAINT FK_C_CONTS_PNO FOREIGN KEY(PNO)
		REFERENCES PROFESSOR_PK(PNO)
);


--36.
--1) 다음 구조를 갖는 테이블을 생성하세요.
--PRODUCT 테이블 - PNO NUMBER PK              : 제품번호
--                PNMAE VARCHAR2(50)          : 제품이름
--                PRI NUMBER                  : 제품단가
--PAYMENT 테이블 - MNO NUMBER PK              : 전표번호
--               PDATE DATE NOT NULL         : 판매일자
--                CNAME VARCHAR2(50) NOT NULL : 고객명
--                TOTAL NUMBER TOTAL > 0      : 총액
--PAYMENT_DETAIL - MNO NUMBER PK FK           : 전표번호
--                PNO NUMBER PK FK            : 제품번호
--                AMOUNT NUMBER NOT NULL      : 수량
--                PRICE NUMBER NOT NULL       : 단가
--                TOTAL_PRICE NUMBER NOT NULL TOTAL_PRICE > 0 : 금액
CREATE TABLE PRODUCT(
	PNO NUMBER PRIMARY KEY,
	PNMAE VARCHAR2(50),
	PRI NUMBER  
);
CREATE TABLE PAYMENT(
	MNO NUMBER PRIMARY KEY,
	PDATE DATE NOT NULL ,
	CNAME VARCHAR2(50) NOT NULL,
	TOTAL NUMBER CHECK(TOTAL>0)
);
CREATE TABLE PAYMENT_DETAIL(
	MNO NUMBER,
	PNO NUMBER,
	AMOUNT NUMBER NOT NULL,
	PRICE NUMBER NOT NULL,
	TOTAL_PRICE NUMBER NOT NULL CHECK(TOTAL_PRICE > 0),
	CONSTRAINT PK_PAYMENT_DETAIL_M_P PRIMARY KEY(MNO,PNO),
	CONSTRAINT FK_PAYMENT_DETAIL_M_P FOREIGN KEY(MNO,PNO)
);

--37,
--1) 과목번호, 과목이름, 교수번호, 교수이름을 담을 수 있는 변수들을 선언하고 
--   유기화학 과목의 과목번호, 과목이름, 교수번호, 교수이름을 출력하세요.
--DECLARE
--	COURSE_ROW COURSE%ROWTYPE;
--	PROFESSOR_ROW PROFESSOR%ROWTYPE;
--BEGIN
--	SELECT * INTO COURSE_ROW,
--	SELECT * INTO PROFESSOR_ROW
--		FROM COURSE C
--		JOIN PROFESSOR p 
--		  ON C.PNO=P.PNO
--		WHERE C.CNAME = '유기화학';
--	DBMS_OUTPUT.PUT_LINE(COURSE_ROW.CNO);
--END;

DECLARE
    COURSE_ROW COURSE%ROWTYPE;
    PROFESSOR_ROW PROFESSOR%ROWTYPE;
BEGIN
    SELECT C.CNO,C.CNAME,P.PNO,P.PNAME --*
    		--이 부분을 그냥 COURSE_ROW,PROFESSOR_ROW 이렇게 작성하면 왜 안되는지 ㅇㅅㅇ???
    	INTO COURSE_ROW.CNO,COURSE_ROW.CNAME,PROFESSOR_ROW.PNO,PROFESSOR_ROW.PNAME
    FROM PROFESSOR P
    JOIN COURSE C 
      ON P.PNO = C.PNO
    WHERE C.CNAME = '유기화학';

    DBMS_OUTPUT.PUT_LINE(COURSE_ROW.CNO);
    DBMS_OUTPUT.PUT_LINE(COURSE_ROW.CNAME);
    DBMS_OUTPUT.PUT_LINE(PROFESSOR_ROW.PNO);
    DBMS_OUTPUT.PUT_LINE(PROFESSOR_ROW.PNAME);
END;

--2) 위 데이터들을 레코드로 선언하고 출력하세요.
DECLARE
	TYPE COURSE_REC IS RECORD(
		CNO COURSE.CNO%TYPE,
		CNAME COURSE.CNAME%TYPE
	);
	TYPE PROFESSOR_REC IS RECORD(
		PNO PROFESSOR.PNO%TYPE,
		PNAME PROFESSOR.PNAME%TYPE
	);

	COURSE_ROW COURSE_REC;
	PROFESSOR_ROW PROFESSOR_REC;

BEGIN
	SELECT C.CNO,C.CNAME,P.PNO,P.PNAME
    	INTO COURSE_ROW.CNO,COURSE_ROW.CNAME,PROFESSOR_ROW.PNO,PROFESSOR_ROW.PNAME
    FROM PROFESSOR P
    JOIN COURSE C 
      ON P.PNO = C.PNO
    WHERE C.CNAME = '유기화학';

    DBMS_OUTPUT.PUT_LINE(COURSE_ROW.CNO);
    DBMS_OUTPUT.PUT_LINE(COURSE_ROW.CNAME);
    DBMS_OUTPUT.PUT_LINE(PROFESSOR_ROW.PNO);
    DBMS_OUTPUT.PUT_LINE(PROFESSOR_ROW.PNAME);
END;



